module ViolasToken {

    import 0x00.LibraAccount;
    import 0x0.LibraCoin;
    import 0x00.Hash;
    import 0x0.Event;
    import 0x0.U64Util;
    import 0x0.AddressUtil;
    import 0x0.BytearrayUtil;
    
    resource Owner { }

    // A resource representing the ViolasToken
    resource T {
        value: u64,
    }

    resource TokenAddr {
        addr: address,
    }
    
    resource Info {
        allinone_events: Event.Handle<Self.AllInOneEvent>,
    }

    resource OwnerData {
        data: bytearray,
    }
    
    resource Order {
        token: Self.T,
        price: u64,
    }

    resource Order2 {
        token: LibraCoin.T,
        price: u64,
    }
    
    struct AllInOneEvent {
        etype: u64, 
        sender: address,
        receiver: address,
        token: address,
        amount: u64,
        price: u64,
        data: bytearray,
    }
    
    // Publishes an initial zero dToken to the sender.
    public publish() acquires Info {

        let sender: address;
        sender = get_txn_sender();

        if(exists<T>(copy(sender))) {
            return;
        }

        if (copy(sender) == {{sender}}) {
            move_to_sender<Owner>(Owner{});
        }
        
        move_to_sender<T>(T{ value: 0 });

        move_to_sender<TokenAddr>(TokenAddr{ addr: {{sender}} });

        move_to_sender<Info>(Info{
            allinone_events: Event.new_event_handle<Self.AllInOneEvent>(),
        });

        Self.emit_events(0, copy(sender), 0, 0, h"");
        
        return;
    }

    public owner_publish(data: bytearray) acquires Info {

        let sender: address;
        sender = get_txn_sender();

        if(exists<T>(copy(sender))) {
            return;
        }

        if (copy(sender) == {{sender}}) {
            move_to_sender<Owner>(Owner{});
        }
        
        move_to_sender<T>(T{ value: 0 });

        move_to_sender<TokenAddr>(TokenAddr{ addr: {{sender}} });

        move_to_sender<Info>(Info{
            allinone_events: Event.new_event_handle<Self.AllInOneEvent>(),
        });

        move_to_sender<OwnerData>(OwnerData{ data: copy(data) });
        
        Self.emit_events(9, copy(sender), 0, 0, move(data));
        
        return;
    }
    
    require_published() {
        let sender: address;
        let is_present: bool;
        sender = get_txn_sender();
        is_present = exists<T>(move(sender));
        assert(move(is_present), 101);
        return;
    }
    
    require_owner() {
        let sender: address;
        let is_present: bool;
        sender = get_txn_sender();
        is_present = exists<Owner>(move(sender));
        assert(move(is_present), 102);
        return;
    }

    // Mint new dTokens.
    mint(value: u64): Self.T {
        Self.require_published();
        Self.require_owner();
        return T{value: move(value)};
    }

    public mint_to_address(payee: address, amount: u64) acquires T, Info {

        let token: Self.T;
        token = Self.mint(copy(amount));
        
        // Mint and deposit the coin
        Self.deposit(copy(payee), move(token));

        Self.emit_events(1, copy(payee), copy(amount), 0, h"");
        
        return;
    }
    
    value(coin_ref: &Self.T): u64 {
        return *&move(coin_ref).value;
    }
    
    // Returns an account's dToken balance.
    balance(): u64  acquires T {
        let sender: address;
        let token_ref: &Self.T;
        let token_value: u64;

        Self.require_published();
        
        sender = get_txn_sender();
        token_ref = borrow_global<T>(move(sender));
        token_value = *(&move(token_ref).value);

        return move(token_value);
    }

    // Deposit owned tokens to a payee's address
    deposit(payee: address, to_deposit: Self.T) acquires T {
        let sender: address;
        let amount: u64;
        
        let payee_token_ref: &mut Self.T;
        let payee_token_value: u64;
        let to_deposit_value: u64;

        Self.require_published();

        sender = get_txn_sender();
        
        payee_token_ref = borrow_global_mut<T>(copy(payee));
        payee_token_value = *(&copy(payee_token_ref).value);

        // Unpack and destroy to_deposit tokens
        T{ value: to_deposit_value } = move(to_deposit);

        amount = copy(to_deposit_value);
        
        // Increase the payees balance with the destroyed token amount
        *(&mut move(payee_token_ref).value) = move(payee_token_value) + move(to_deposit_value);

        return;
    }
    
    // Withdraw an amount of tokens of the sender and return it.
    withdraw(amount: u64): Self.T acquires T {
        let sender: address;
        let sender_token_ref: &mut Self.T;
        let value: u64;

        Self.require_published();

        sender = get_txn_sender();
        
        sender_token_ref = borrow_global_mut<T>(move(sender));
        value = *(&copy(sender_token_ref).value);

        // Make sure that sender has enough tokens
        assert(copy(value) >= copy(amount), 103);

        // Split the senders token and return the amount specified
        *(&mut move(sender_token_ref).value) = move(value) - copy(amount);
        return T{ value: move(amount) };
    }

    pay_from_sender(payee: address, amount: u64) acquires T {
        let sender: address;
        let to_pay: Self.T;

        Self.require_published();

        sender = get_txn_sender();
        
        to_pay = Self.withdraw(copy(amount));
        Self.deposit(copy(payee), move(to_pay));
        
        return;
    }

    public transfer(payee: address, amount: u64) acquires T, Info {
        Self.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(2, copy(payee), copy(amount), 0, h"");
        return;
    }

    public transfer_with_data(payee: address, amount: u64, data: bytearray) acquires T, Info {
        Self.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(12, copy(payee), copy(amount), 0, move(data));
        return;
    }
    
    public transfer_vcoin_with_data(payee: address, amount: u64, data: bytearray) acquires Info {
        LibraAccount.pay_from_sender(copy(payee), copy(amount));
        Self.emit_events(10, copy(payee), copy(amount), 0, move(data));
        return;
    }
    
    public make_order(amount: u64, price: u64, flag: u64) acquires T, Info {
        let sender: address;
        let token: Self.T;
        let token2: LibraCoin.T;
        let sender_info_ref: &mut Self.Info;

        Self.require_published();

        sender = get_txn_sender();

        if(copy(flag) == 0) {
            token = Self.withdraw(copy(amount));
            move_to_sender<Order>(Order { token: move(token), price: copy(price)});
            Self.emit_events(3, copy(sender), copy(amount), copy(price), h"");
        }

        if(copy(flag) == 1) {
            token2 = LibraAccount.withdraw_from_sender(copy(amount));
            move_to_sender<Order2>(Order2 { token: move(token2), price: copy(price)});
            Self.emit_events(6, copy(sender), copy(amount), copy(price), h"");
        }
        
        return;
    }

    public cancel_order(flag: u64) acquires T, Order, Order2, Info {
        let sender: address;
        let order: Self.Order;
        let order2: Self.Order2;
        let token: Self.T;
        let token2: LibraCoin.T;
        let price: u64;
        let sender_info_ref: &mut Self.Info;
        let amount: u64;
        
        Self.require_published();
        
        sender = get_txn_sender();

        if(copy(flag) == 0) {
            order = move_from<Order>(copy(sender));
            Order { token:token, price:price } = move(order);
            amount = Self.value(&token);
            Self.deposit(copy(sender), move(token));
            Self.emit_events(4, copy(sender), copy(amount), copy(price), h"");
        }        

        if(copy(flag) == 1) {
            order2 = move_from<Order2>(copy(sender));
            Order2 { token:token2, price:price } = move(order2);
            amount = LibraCoin.value(&token2);
            LibraAccount.deposit(copy(sender), move(token2));
            Self.emit_events(7, copy(sender), copy(amount), copy(price), h"");
        }        
        
        return;
    }
    
    // Currently only support buy whole order, not support split order.
    public take_order(maker: address, amount_in: u64, price_in: u64, flag: u64) acquires T, Order, Order2, Info {
        let sender: address;
        let order: Self.Order;
        let order2: Self.Order2;
        let token: Self.T;
        let token2: LibraCoin.T;
        let price: u64;

        let sender_info_ref: &mut Self.Info;
        let amount: u64;
        
        Self.require_published();
        
        sender = get_txn_sender();

        if(copy(flag) == 0) {
            order = move_from<Order>(copy(maker));
            Order { token:token, price:price } = move(order);
            amount = Self.value(&token);
            assert(copy(amount) == copy(amount_in), 104);
            assert(copy(price) == copy(price_in), 105);
            LibraAccount.pay_from_sender(copy(maker), copy(price));
            Self.deposit(copy(sender), move(token));
            Self.emit_events(5, copy(maker), copy(amount), copy(price), h"");
        }
        
        if(copy(flag) == 1) {
            order2 = move_from<Order2>(copy(maker));
            Order2 { token:token2, price:price } = move(order2);
            amount = LibraCoin.value(&token2);
            assert(copy(amount) == copy(amount_in), 104);
            assert(copy(price) == copy(price_in), 105);
            Self.pay_from_sender(copy(maker), copy(price));
            LibraAccount.deposit(copy(sender), move(token2));
            Self.emit_events(8, copy(maker), copy(amount), copy(price), h"");
        }
        
        return;
    }

    public record(data: bytearray) acquires Info {
        let sender: address;
        sender = get_txn_sender();
        Self.emit_events(11, copy(sender), 0, 0, move(data));
        return;
    }
    
    emit_events(etype: u64, receiver: address, amount: u64, price: u64, data: bytearray) acquires Info {

        let sender: address;
        let token: address;
        
        let allinone_event: Self.AllInOneEvent;
        
        let sender_info_ref: &mut Self.Info;
        let receiver_info_ref: &mut Self.Info;
        
        sender = get_txn_sender();
        token = {{sender}};

        allinone_event = AllInOneEvent {
            etype: copy(etype),
            sender: copy(sender),
            receiver: copy(receiver),
            token: copy(token),
            amount: move(amount),
            price: move(price),
            data: move(data),
        };

        if(true) {
            sender_info_ref = borrow_global_mut<Info>(copy(sender));
            Event.emit_event<Self.AllInOneEvent>(&mut move(sender_info_ref).allinone_events, copy(allinone_event));
        }

        if((copy(etype) == 1)  ||
           (copy(etype) == 2)  ||
           (copy(etype) == 5)  ||
           (copy(etype) == 8)  ||
           (copy(etype) == 10) ||
           (copy(etype) == 12))
        {
            receiver_info_ref = borrow_global_mut<Info>(copy(receiver));  
            Event.emit_event<Self.AllInOneEvent>(&mut move(receiver_info_ref).allinone_events, copy(allinone_event));
        }
        
        return;
    }
    
}










